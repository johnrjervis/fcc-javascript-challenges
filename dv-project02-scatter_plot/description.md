# Visualise data with a scatter plot

This is my solution to [the second of freeCodeCamp's D3 certification project challenges].

The official tests for this challenge are in the [fCC test bundle script].

The data for this challenge relates to the fastest recorded ascents of Alpe d'Huez by racing cyclists and this is available from [the project reference section of fCC's github repo].

## While working on this project, I made the following notes:

- Some of the objects in the datset have matching time and year properties; when this occurs, multiple datapoints occupy the same position and the top datapoint obscures the others. At most, there are three datapoints that share the same time and year (at 39:47 and 2006). To account for this, I have added multiple tool tips: the code scans for matches in the data and displays the required number of tool tips and hides any that are not needed.
- Once I had completed this challenge, I refactored my code so that everything was contained within a ScatterPlot class. Although only one instance of ScatterPlot is needed, I think I prefer the class-based approach as the code feels better organised and easier to maintain. (Although this could be as much due to the refactoring as to the use of a class!)
- One issue that I encountered when working with a class is that inside an event handler, `this` refers to the event target instead of the class instance. To allow the class instance to be accessed inside the event handler, I referenced `this` to a variable in the method scope that contained the event handler. I could also have used `bind`, but using a variable meant I still had access to the event target via `this` in the event handler. I found this [article on 'this' in event handlers on Stack Overflow] provides a useful explanation.
- Accessing the event target via `this` was useful for passing the index of the data to the event listener. I did this by using a local variable (`const index = d3.local();`) and storing the index in the local variable with `.each(function(d, i) {index.set(this, i);})` within the d3 code for generating the datapoints. The index could then be accessed within the datapoints' mouseover event handler with `index.get(this)`. This [Stack Overflow aticle on passing the data index to an event listener] was helpful for solving this problem.
- I used tspans to allow the SVG text tool tips to be partially updated with text from the objects in the dataset. This meant I didn't have to replace all of the text every time the mouseover event listener was called. I also used a tspan to avoid having the underline styling for the legend title continuing under the asterisk at its end. I'd not come across tspans before this project, but this [MDN Reference article on tspans] neatly explains their usefulness.
- In the method that creates the legend, I added a  dimensions object that sets the size and position of the legend. It's possibly a bit over-complicated but it does make adjusting the legend much easier (once you know what each of the object's properties represent).
- When working with `Date` objects to represent the time taken for the cyclists to ride up the Alpe, I had some issues with getting the correct values. I got around these problems initially by creating a new `Date` object with `const ascentTime = new Date()` and using `ascentTime.setSeconds(0, 0, 0)` to clear the hours minutes and seconds of the time before calling setSeconds again with the data object's `Seconds` property as its argument to set the correct time. I later found that it was possible to avoid the need to 'clear' the time by using `const ascentTime = new Date(0)` when creating the `Date` object.
- Once again, I wrote my own unit tests for this project with [QUnit]. The tests were useful when I decided to reorganise all of my code into a class. For completeness, it would have been nice to write some functional tests (e.g. with Selenium) to test the mouse hover interaction for the tool tips - especially for checking that multiple tool tips are displayed with the correct information when there are time & year clashes in the data. (Maybe I'll come back to this at some point; for now I'm just adding it to a lengthy 'to do' list!)
- It's possible that some of the tests (e.g. those for the xScale and yScale properties of the ScatterPlot class) are bordering on testing the framework, which is sometimes discouraged. Having never worked d3 code into a class before, I'd say I was testing my implementation of the framework (to make sure I hadn't got things horribly wrong!).
- While working on this project, I found it useful to have a local test dataset (e.g. by saving the JSON data in a local file, or defining a simple test dataset in the tests file). I found hacking around in the console much easier when I could just create a new ScatterPlot with, e.g., `const testGraph = new ScatterPlot(testData)`.
- As with my Bar Chart, I took my style cue from Jon Lomberg's artwork for the book 'Comet' by Carl Sagan & Ann Druyan. I really do love Lomberg's diagrams in that book!

[the second of freeCodeCamp's D3 certification project challenges]: https://www.freecodecamp.org/learn/data-visualization/data-visualization-projects/visualize-data-with-a-scatterplot-graph
[fCC test bundle script]: https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js
[the project reference section of fCC's github repo]: https://raw.githubusercontent.com/freeCodeCamp/ProjectReferenceData/master/cyclist-data.json
[article on 'this' in event handlers on Stack Overflow]: https://stackoverflow.com/questions/5490448/how-do-i-pass-the-this-context-into-an-event-handler
[Stack Overflow aticle on passing the data index to an event listener]: https://stackoverflow.com/questions/64910052/d3-js-v6-2-get-data-index-in-listener-function-selection-onclick-listene
[MDN Reference article on tspans]: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan
[QUnit]: https://qunitjs.com/
